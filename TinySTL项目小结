# TinySTL项目介绍
- 项目描述
使用C++11，数据结构及算法，模板编程等知识，参考SGI STL的实现及＜STL源码剖析＞一书，编写了一个简易的STL标准库．
项目地址： https://github.com/yyehl/TinySTL
实现的模块包括：
１．空间配置器：运用内存池与两级配置器，预防内存碎片化
２．迭代器：运用traits类型萃取技术，实现对内置类型的高效处理
３．常用容器及适配器：实现了vector, list, map, hashmap等常用容器以及stack, queue等适配器．
４．常用算法：实现了排序，二分查找的常用算法．
５．仿函数等．
---
- **说说你的内存池与两级配置器是怎么实现的？**
第一级处理较大区块（大于128字节）的内存申请，直接调用库函数malloc来申请内存的
第二级配置器配合内存池专门处理小区块的内存申请
每次先用malloc申请一大块连续的内存，用两个指针start, end来维护这个内存池
从8字节开始，16字节，24字节，一直到128字节划分为16种区块大小，维护一个free_list数组，负责配置跟回收每种区块大小的内存
当有小区块的内存申请时，就先看free_list里面还有没有相应大小的区块，如果没有，就去内存池申请，如果内存池不够了，再重新申请一个内存池．
如果有小区块需要回收的话，就回收到相应大小的free_list中，以便下次其他人申请．
如果申请的内存不是刚好8字节的倍数的话，比如7个字节，就给它分配8字节，13字节，就给他分配16字节，这样的话，容易分配出去，也容易回收．
因为内存池的都是申请的连续大区块内存，而小区块内存都是在内存池中申请，所以这就避免了不断申请释放小区块内存而可能导致的内存碎片化问题

- **内存申请内存失败会怎么样？**
１．先申请另一个内存池
２．若无法满足，就转而申请一个小块内存，以便能满足刚刚小块内存
３．如无法满足，则去free_list里面查找，其他尺寸的能满足要求的空闲内存块，如果有的话就给他分配
４．若还是无法满足，则我的处理办法是一直递归调用自身，循环申请，等待被释放的内存．如果一直申请不到，就会导致栈溢出，程序就奔溃了．

- **既然是小区块内存的申请了，还要维护一个指针，那不是会增加额外的负担？**
对，本来就只是8字节16字节小区块的内存，还要维护一个4字节指针，确实比较浪费
为了解决这个问题，我用了union的数据结构
```
union obj {
	obj *next;  // 当被回收时，用这个指向下一个相同大小的区块，来维护这个空闲链表
	char *client;  // 当被分配出去了，就可以指向一个区块
}
```
所以free_list里面存的就是这样的数据结构，可以解决额外消耗的问题

- **说一说union这个数据结构？**
union这个数据结构一般是在对内存很敏感的地方使用
union的大小是它的数据成员大小的最大值，所有的成员公用一个内存位置
它每次只能表示它其中的一种数据成员
如果union的其中一种数据成员写入数据的话，那么其他数据成员的数据也就被擦除了．

- **说一说什么是内存碎片？**
我觉得内存碎问题分为两种
**第一种是操作系统角度的内存管理可能会导致内存碎片**
**第二种是程序动态分配内存可能导致的内存碎片**
**第一种**：因为进程要运行，得先上内存，进程需要的空间有大有小，如果采用分段式的内存分配，那么分配释放多次后，就可能导致，空闲的内存空间被隔离成一小段一小段的，本来还有很多空闲空间，但是一个稍大的进程需要进内存，却出现空间不足的问题．这个就是内存碎片，准确的来说是外部内存碎片．
解决办法就是采用分页．分页就是内存空间都分配成若干个大小固定的页框，进程的空间都分配成若干个大小固定的页面，一个页框对应一个页面，这样的话，就不需要连续内存了，也就避免了外部内存碎片的问题．但是会出现一些内部内存碎片，比如说这个进程只需要２个页面多１字节的空间，那还是得给它分配３个页面才够，这最后一个页面中分配了却没有被使用的空间就是内部内存碎片．
**第二种**：是程序在执行过程中，动态分配堆内存，可能会导致的内存碎片问题．第二种其实有点像第一种操作系统问题的缩小版．
如果不断分配和释放小区块内存的话，就可能导致进程地址空间的堆内存产生碎片化．也就是空闲内存被小内存分割成一小段一小段的，本来还存在挺多的空闲空间，但是却不能满足一个较大的连续空间的内存请求，这就是第二种情况的外部内存碎片．为了避免这种情况，就可以采用内存池的方法．
其实第二种情况也可能存在内部内存碎片，比如我的STL项目里面采用的第二级空间配置器，对于小内存采用向上向８的倍数取整的方法，比如我需要６个字节的空间，它会给我分配８内存．那么多余的２个字节就是内部内存碎片．

- **为什么用的malloc而不是new？**
１．肯定不是用关键字new，因为只需要分配内存，不需要构造对象
２．为什么不用operator new，其实确实可以用operator new，因为operator new也是分配内存，它与malloc的区别仅限于对分配失败时的处理，malloc分配失败是直接返回NULL，operator new分配失败若指定了new_handle，则用new_handle，若没有，则看若为定义nothrow（不发出异常），则发出BAD_ALLOC异常，无定义了不发出异常，则直接返回０．
本质来说，operator new也是调用了malloc的，所以用谁都可以，区别不大
３．肯定也不是指的用placement new，因为它是在已分配内存后在指定位置构造对象的，不过在construct类里面，确实用的是placement new 

```
template <class T1, class T2>
inline void construct(T1 *p, const T2& val)
{ 
	new(p) T2(val);  // 调用placement new与 构造函数T2::T2()
}
```

- **说说malloc与new的区别？**
１．malloc是库函数，它们只负责分配内存与释放内存
２．new一般有三层意思
１）第一层就是最常用的关键字new，负责分配内存，并构造对象．这是C++语言标准规定的，无法改变．分配内存调用operator new，构造对象调用构造函数
２）第二层就是operator new，它只负责分配内存．它与加减乘除四则运算符一样，是可以重载的，会覆盖全局::operator new．
operator new 与 malloc 的区别：
operator new 的申请内存也是调用了malloc的，它们之间的区别只是在分配内存失败后的处理不同
malloc是分配失败直接返回NULL
operator new分配失败的话，如果设置有new_handle，则执行new_handle，如果没有，则看是否设置了nothrow（不发出异常），如果没有则发出bad_alloc异常，如果设置了不发出异常，就直接返回０．
３）第三层就是placement new，它是operator new 的一个特殊的全局重载版本，它不负责分配内存．它接收一个指针，并直接返回指针．主要用于在已分配内存时，在指定的地址构造对象
---
- **迭代器有哪些设计难点？**
STL的中心思想是把容器与算法分开设计，而迭代器就是把容器和算法粘合在一起的粘合剂．
**１．如何封装住容器的实现细节？**
因为容器有很多种，比如最简单的vector跟list，一个可以随机访问，另一个只能顺序访问．如果迭代器统一设计的话，必然要暴露很多内部细节，所以最终迭代器是决定每个容器单独设计自己的迭代器．这样就可以完全封装住容器的内部实现
**２．如何推导迭代器所指对象的类型？**
如果一个算法接收一个迭代器为参数，但是需要迭代器所指的类型，怎么办呢？
此时使用模板的参数推导可以实现，调用另一个接收迭代器与迭代器所指类型两个参数的函数来实现就行了．
但是如果是返回值需要迭代器所指的类型呢？模板参数推导就不能推导出来了．因为参数推导只是推导函数的参数，而不能推导返回值．
使用迭代器类内嵌类型来可以解决这个问题．在每个迭代器内部内嵌类型成员value_type, difference_type, pointer, reference, iterator_category．这样就可以推导出迭代器所指类型的问题了．
但是还有一个问题，迭代器必须支持内置类型，也就是说原生指针也是一种迭代器，但是原生指针没有相应的类，也就无法在它的类里面内嵌类型，那怎么办呢？
解决办法是**traits的迭代器萃取技术与模板偏特化．**
定义一个iterator_traits类，如果迭代器内嵌有自己的类别，那么就直接萃取出它相应的类别．如果是原生指针，那么就为其重新定义一个偏特化版本，专门处理原生指针的问题．
**３．容器类型众多，对象类型众多，如何为特定类型设计特定的迭代器以提高效率？**
STL里面容器类型众多，比如最简单的vector，list两种容器，vector可随机访问，list只能顺序访问．比如advance(n)函数，需要迭代器向前走n步，如果统一设计的话，vector只能和list一样，一步一步的往前走．而显然，对于vector来说，这是一种低效率的方式．因为它本可以直接访问到目的地的
它的解决办法就可以依赖上面提到的**iterator_traits迭代器萃取技术**，将迭代器的特性萃取出来，是random access iterator 还是 forward iterator，当然，这需要迭代器的内嵌类型的支持，其实**萃取技术都需要迭代器内嵌类型的支持**．不同特性采取不同的处理方式，以提高效率
又比如，如果一个类型是内置类型，没有构造函数，析构函数等，对它们进行构造，析构时如果与其他复杂类型采取同样的方式，那么显然这也是一种低效的行为．因为它们可以直接使用malloc，mencpy等高效的处理方式．
那么如何把不同的类型区分开来呢？
解决办法是**类型萃取技术**．设计一个**type_traits类**，**先对每个类型赋予一个最保守的值，然后再对特定类型进行偏特化，特殊类型特殊处理**．type_traits就负责萃取出特定类型的特性，以便对特定的类型采取效率最优的处理方式．

- **什么是traits萃取技术？**
在STL中，traits萃取技术有两个应用，一个是迭代器萃取技术，另一个是类型萃取技术．
traits萃取技术主要是通过内嵌类型成员的方式，再设计一个traits类间接萃取出类型的内嵌类型，然后通过偏特化对特定类型设计特定的处理方式，以提高效率．
iterator_traits迭代器萃取技术主要是为了解决有时候需要知道迭代器所指类型的情况．先在迭代器中内嵌value_type等类型成员，再设计一个iterator_traits类，负责萃取出迭代器的所指类型，并且对于原始指针，无法内嵌类型成员，则可以通过偏特化的方式解决．
type_traits类型萃取技术主要是为了解决不同类型的容器或对象具有不同的性质，对于特定的对象，应该可以采用特定的处理方式来提高效率．先设计一个type_traits类，对所有的类型赋予一个保守值，然后对特定类型进行偏特化，以便类型萃取时能够萃取出特定类型的特性，设计特定的处理方式．

- **仿函数是什么？**

- **模板偏特化是什么？**

- **说一说项目中用到了哪些C++11新特性**？

- **说一说C++11与之前有哪些不一样的地方**？

- **说一说你对模板编程的理解**？

- **说一说SGI STL与其他版本的STL的区别**？
 
- **看过boost源码吗**？

- **STL是线程安全的吗**？

- **STL为什么没有考虑线程安全，如果要考虑该怎么考虑**？

- **你觉得这个项目的难点（或亮点）是什么**？

- **你有在STL的基础上有自己的创新吗**